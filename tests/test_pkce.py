"""
Unit tests for PKCE generation utilities.
"""
import pytest
import re
import hashlib
import base64

from mcp_vacuum.auth.pkce import generate_pkce_challenge_pair
from mcp_vacuum.models.auth import PKCEChallenge

def test_generate_pkce_s256():
    """Test S256 PKCE challenge generation."""
    pkce_pair = generate_pkce_challenge_pair(code_challenge_method="S256")

    assert isinstance(pkce_pair, PKCEChallenge)
    assert pkce_pair.code_challenge_method == "S256"

    # Verifier constraints (as per RFC 7636: 43-128 chars, unreserved characters)
    assert 43 <= len(pkce_pair.code_verifier) <= 128
    assert re.match(r"^[A-Za-z0-9\-._~]*$", pkce_pair.code_verifier), "Verifier contains invalid characters"

    # Challenge constraints (Base64url encoding of SHA256 hash)
    # SHA256 digest is 32 bytes. Base64url encoding of 32 bytes is 43 characters ( (32 * 4/3) rounded up, then remove padding).
    # (Actually, (32 * 8 / 6) = 42.66, so 43 chars. Example: `echo -n "test" | sha256sum | head -c 32 | base64url` needs 32 bytes input for hash)
    # The digest of the verifier should result in a 43-char challenge after base64url encoding and padding removal.
    expected_challenge = base64.urlsafe_b64encode(
        hashlib.sha256(pkce_pair.code_verifier.encode("ascii")).digest()
    ).decode("ascii").rstrip("=")
    assert pkce_pair.code_challenge == expected_challenge
    assert len(pkce_pair.code_challenge) == 43 # Base64URL of SHA256 hash is always 43 chars

def test_generate_pkce_plain():
    """Test 'plain' PKCE challenge generation."""
    pkce_pair = generate_pkce_challenge_pair(code_challenge_method="plain")

    assert isinstance(pkce_pair, PKCEChallenge)
    assert pkce_pair.code_challenge_method == "plain"
    assert 43 <= len(pkce_pair.code_verifier) <= 128
    assert re.match(r"^[A-Za-z0-9\-._~]*$", pkce_pair.code_verifier)

    # For "plain", challenge is the same as verifier
    assert pkce_pair.code_challenge == pkce_pair.code_verifier

def test_generate_pkce_unsupported_method():
    """Test error handling for unsupported challenge methods."""
    with pytest.raises(ValueError) as excinfo:
        generate_pkce_challenge_pair(code_challenge_method="MD5")
    assert "Unsupported code_challenge_method: MD5" in str(excinfo.value)

def test_pkce_verifier_length_generation():
    """Test that verifiers of different valid lengths can be implicitly generated by the model if not the function."""
    # The function generate_pkce_challenge_pair uses a fixed length internally for token_urlsafe.
    # PKCEChallenge model itself has min_length/max_length which Pydantic would enforce if values were passed directly.
    # This test is more about ensuring the default generation within the function meets RFC.
    for _ in range(10): # Repeat a few times for randomness
        pkce_pair = generate_pkce_challenge_pair() # Defaults to S256
        assert 43 <= len(pkce_pair.code_verifier) <= 128
        # The current implementation of generate_pkce_challenge_pair aims for max length (128)
        assert len(pkce_pair.code_verifier) == 128

        pkce_pair_plain = generate_pkce_challenge_pair(code_challenge_method="plain")
        assert 43 <= len(pkce_pair_plain.code_verifier) <= 128
        assert len(pkce_pair_plain.code_verifier) == 128

# To truly test different lengths generated by `secrets.token_urlsafe(n)[:length]`,
# one might need to parameterize `generate_pkce_challenge_pair` or test the model directly.
# However, the current function `generate_pkce_challenge_pair` internally uses `secrets.token_urlsafe(96)[:128]`,
# so the verifier length will always be 128. The model's validation (43-128) is separate.
# The tests above confirm the generated verifier (which is 128 chars) is valid.
